import { RequestHandler } from "express";
import { z } from "zod";
import { GoogleGenerativeAI } from "@google/generative-ai";
import type { AdvisoryRequest, AdvisoryResponse, LangCode } from "@shared/api";

const ReqSchema = z.object({
  question: z.string().optional(),
  imageBase64: z.string().optional(),
  lang: z.custom<LangCode>(),
});

const titles: Record<string, string> = {
  en: "Crop Advisory",
  ml: "р┤Хр╡Гр┤╖р┤┐ р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤В",
  hi: "рдХреГрд╖рд┐ рд╕рд▓рд╛рд╣",
  mr: "рдкрд┐рдХ рд╕рд▓реНрд▓рд╛",
  kn: "р▓мр│Жр▓│р│Ж р▓╕р▓▓р▓╣р│Ж",
  gu: "рккрк╛ркХ рк╕рк▓рк╛рк╣",
  te: "р░кр░Вр░Я р░╕р░▓р░╣р░╛",
};

const stepsMap: Record<string, string[]> = {
  en: ["Inspect leaves", "Isolate affected area", "Apply organic pesticide", "Control irrigation"],
  ml: ["р┤Зр┤▓р┤Хр╡╛ р┤кр┤░р┤┐р┤╢р╡Лр┤зр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤мр┤╛р┤зр┤┐р┤д р┤нр┤╛р┤Чр┤В р┤╡р╡Зр╡╝р┤др┤┐р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤Ьр╡Ир┤╡ р┤Хр╡Ар┤Яр┤ир┤╛р┤╢р┤┐р┤ир┤┐ р┤кр╡Нр┤░р┤пр╡Лр┤Чр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤╡р╡Жр┤│р╡Нр┤│р┤В р┤ир┤┐р┤пр┤ир╡Нр┤др╡Нр┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х"],
  hi: ["рдкрддреНрддреЛрдВ рдХреА рдЬрд╛рдБрдЪ рдХрд░реЗрдВ", "рд╕рдВрдХреНрд░рдорд┐рдд рднрд╛рдЧ рдЕрд▓рдЧ рдХрд░реЗрдВ", "рдЬреИрд╡рд┐рдХ рдХреАрдЯрдирд╛рд╢рдХ рд▓рдЧрд╛рдПрдБ", "рд╕рд┐рдВрдЪрд╛рдИ рдирд┐рдпрдВрддреНрд░рд┐рдд рдХрд░реЗрдВ"],
  mr: ["рдкрд╛рдиреЗ рддрдкрд╛рд╕рд╛", "рд╕рдВрдХреНрд░рдорд┐рдд рднрд╛рдЧ рд╡реЗрдЧрд│рд╛ рдХрд░рд╛", "рд╕реЗрдВрджреНрд░рд┐рдп рдХреАрдЯрдХрдирд╛рд╢рдХ рд╡рд╛рдкрд░рд╛", "рдкрд╛рдгреА рдирд┐рдпрдВрддреНрд░рд┐рдд рдХрд░рд╛"],
  kn: ["р▓Ор▓▓р│Жр▓Чр▓│р▓ир│Нр▓ир│Б р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓┐р▓╕р▓┐", "р▓кр│Ар▓бр▓┐р▓д р▓нр▓╛р▓Чр▓╡р▓ир│Нр▓ир│Б р▓мр│Зр▓░р│Нр▓кр▓бр▓┐р▓╕р▓┐", "р▓╕р│Зр▓Вр▓жр│Нр▓░р│Ар▓п р▓Хр│Ар▓Яр▓ир▓╛р▓╢р▓Х р▓мр▓│р▓╕р▓┐", "р▓ир│Ар▓░р▓╛р▓╡р▓░р▓┐ р▓ир▓┐р▓пр▓Вр▓др│Нр▓░р▓┐р▓╕р▓┐"],
  gu: ["рккрк╛ркВркжркбрк╛ ркдрккрк╛рк╕рлЛ", "рк╕ркВркХрлНрк░ркорк┐ркд ркнрк╛ркЧ ркЕрк▓ркЧ ркХрк░рлЛ", "рк╕ркЬрлАрк╡ ркХрлАркЯркирк╛рк╢ркХ рк▓ркЧрк╛рк╡рлЛ", "рк╕рк┐ркВркЪрк╛ркИ ркирк┐ркпркВркдрлНрк░рк┐ркд ркХрк░рлЛ"],
  te: ["р░Жр░Хр▒Бр░▓р░ир▒Б р░кр░░р░┐р░╢р▒Ар░▓р░┐р░Вр░Ър░Вр░бр░┐", "р░мр░╛р░зр░┐р░д р░нр░╛р░Чр░╛р░ир▒Нр░ир░┐ р░╡р▒Зр░░р▒Бр░Ър▒Зр░пр░Вр░бя┐╜я┐╜я┐╜", "р░╕р▒Зр░Вр░жр▒Нр░░р▒Ар░п р░кр▒Бр░░р▒Бр░Чр▒Бр░ор░Вр░жр▒Б р░╡р░╛р░бр░Вр░бр░┐", "р░кр░╛р░░р▒Бр░жр░▓ р░ир░┐р░пр░Вр░др▒Нр░░р░┐р░Вр░Ър░Вр░бр░┐"],
};

const intro: Record<string, string> = {
  en: "Here are personalized steps for your crop.",
  ml: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤╡р┤┐р┤│р┤пр╡Нр┤Хр╡Нр┤Хр╡Н р┤Жр┤╡р┤╢р╡Нр┤пр┤ор┤╛р┤п р┤╕р┤╣р┤╛р┤п р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤Щр╡Нр┤Щр╡╛ р┤др┤╛р┤┤р╡Ж р┤ир╡╜р┤Хр┤┐р┤пр┤┐р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б.",
  hi: "рдЖрдкрдХреА рдлрд╕рд▓ рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рд╕рд▓рд╛рд╣ рдиреАрдЪреЗ рджреА рдЧрдИ рд╣реИред",
  mr: "рддреБрдордЪреНрдпрд╛ рдкрд┐рдХрд╛рд╕рд╛рдареА рдЖрд╡рд╢реНрдпрдХ рдкрд╛рдпрд▒реНрдпрд╛ рдЦрд╛рд▓реА рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЖрд╣реЗрдд.",
  kn: "р▓ир▓┐р▓ор│Нр▓о р▓мр│Жр▓│р│Жр▓Чр▓╛р▓Чр▓┐ р▓╡р│Ир▓пр▓Хр│Нр▓др▓┐р▓Х р▓╣р▓Вр▓др▓Чр▓│р│Б р▓Хр│Жр▓│р▓Чр│Ж р▓ир│Ар▓бр▓▓р▓╛р▓Чр▓┐р▓жр│Ж.",
  gu: "ркдркорк╛рк░рлА рккрк╛ркХ ркорк╛ркЯрлЗ рк╡рлНркпркХрлНркдрк┐ркЧркд рккркЧрк▓рк╛ркВ ркирлАркЪрлЗ ркЖрккрлЗрк▓ ркЫрлЗ.",
  te: "р░ор▒А р░кр░Вр░Я р░Хр▒Лр░╕р░В р░╕р▒Вр░Ър░ир░▓р▒Б р░Хр▒Нр░░р░┐р░Вр░ж р░Йр░ир▒Нр░ир░╛р░пр░┐.",
};

export const postAdvisory: RequestHandler = async (req, res) => {
  const parsed = ReqSchema.safeParse(req.body as AdvisoryRequest);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { question = "", lang, imageBase64 } = parsed.data;

  // Basic image size validation (~4/3 of bytes to base64 length). Limit ~5MB.
  if (imageBase64) {
    const approxBytes = Math.ceil((imageBase64.length * 3) / 4);
    if (approxBytes > 5 * 1024 * 1024) {
      return res.status(413).json({ error: "Image too large (max 5MB)" });
    }
  }

  const safeQuestion = String(question).slice(0, 2000);
  const useAI = !!process.env.AI_API_KEY;

  let response: AdvisoryResponse;
  if (useAI) {
    try {
      // Initialize Google Gemini AI with configuration
      const genAI = new GoogleGenerativeAI(process.env.AI_API_KEY!);
      const model = genAI.getGenerativeModel({ 
        model: "gemini-2.0-flash-exp", // Use the most reliable available model
        generationConfig: {
          temperature: 0.8, // Slightly higher for more engaging responses
          maxOutputTokens: 3000, // Increased for detailed structured content
        },
      });

      // Create detailed and engaging prompt for comprehensive agricultural advice
      const systemPrompt = `You are Dr. Krishi, a friendly and experienced agricultural expert with 25+ years of field experience across Indian farming systems. You provide detailed, engaging advice that farmers love to read and follow.

CRITICAL: Respond ONLY with a valid JSON object in this exact format:

{
  "title": "ЁЯМ▒ Engaging, actionable title with emoji (max 60 characters)",
  "text": "Detailed, well-formatted agricultural advice with emojis, bullet points, and clear sections",
  "steps": ["ЁЯФН Step 1: Detailed action with timing and method", "ЁЯТз Step 2: Specific treatment with quantities", "ЁЯСА Step 3: Monitoring signs and frequency", "ЁЯЫбя╕П Step 4: Prevention strategy for future"],
  "lang": "${lang}",
  "source": "ai"
}

FORMATTING REQUIREMENTS for the "text" field:
тЬЕ Use emojis throughout for visual appeal (ЁЯМ▒ЁЯРЫЁЯТзЁЯФНЁЯСитАНЁЯМ╛ЁЯТбтЪая╕ПтЬиЁЯЫбя╕ПЁЯТк)
тЬЕ Structure with bold headings like **ЁЯФН What's Happening:** **ЁЯТб Root Cause:** **ЁЯЫая╕П Treatment Plan:**
тЬЕ Use bullet points with тАв or numbered lists 1. 2. 3.
тЬЕ Include encouraging phrases like "Don't worry, this is completely fixable!" or "Many farmers face this issue"
тЬЕ Make it conversational and friendly like talking to a neighbor
тЬЕ Add specific quantities, timings, and local materials (neem, cow dung, etc.)
тЬЕ Include cost estimates in тВ╣ when helpful

CONTENT STRUCTURE for "text" field (aim for 400-600 words):
**ЁЯФН Problem Analysis:**
тАв Identify the issue with empathy and understanding
тАв Explain what's causing this problem in simple terms
тАв Reassure the farmer that this is solvable

**ЁЯТб Why This Happens:**
тАв Common causes (weather, season, soil, pests, nutrients)
тАв When this typically occurs
тАв Risk factors to be aware of

**ЁЯЫая╕П Immediate Action Plan:**
1. **Quick Fix (Today):** Urgent steps to stop damage
2. **Short-term (This Week):** Treatment implementation
3. **Medium-term (This Month):** Recovery monitoring

**ЁЯМ┐ Organic Solutions (Preferred):**
тАв Cost-effective home remedies using local materials
тАв Preparation methods with exact quantities
тАв Application timing and frequency
тАв Expected results and timeline

**тЪЧя╕П Alternative Methods:**
тАв If organic doesn't work sufficiently
тАв Market solutions with cost estimates
тАв When to consider chemical backup (last resort)

**ЁЯСА Monitoring & Signs:**
тАв Daily checks: What to look for
тАв Signs of improvement (timeline: 3-7 days)
тАв Warning signs that need immediate attention
тАв When to seek additional help

**ЁЯЫбя╕П Prevention Strategy:**
тАв Seasonal preparation tips
тАв Soil health maintenance
тАв Natural pest deterrents
тАв Long-term crop management

**ЁЯТк Encouragement & Support:**
тАв Positive reinforcement
тАв Success timeline expectations
тАв Community wisdom and traditional methods
тАв Confidence building for the farmer

WRITING STYLE:
тЬУ Warm, encouraging, and supportive tone
тЬУ Use "you" and "your crops" to be personal  
тЬУ Simple language that any farmer can understand
тЬУ Include local farming terms and practices
тЬУ Add practical tips from years of experience
тЬУ Balance traditional wisdom with modern methods
тЬУ Make it feel like advice from a trusted friend

STEPS field requirements (each step 20-40 words):
ЁЯФН Use relevant emojis at the start of each step
ЁЯФН Include specific timing (morning/evening, daily/weekly)
ЁЯФН Mention exact quantities and measurements
ЁЯФН Give clear, actionable instructions
ЁЯФН Start with most urgent, end with prevention`;

      let prompt = systemPrompt + `

FARMER'S QUESTION: "${safeQuestion}"

CONTEXT & GUIDELINES:
ЁЯМН Location: Indian agricultural context (diverse climate zones)
ЁЯСитАНЁЯМ╛ Farmer Profile: Small to medium-scale farming, resource-conscious
ЁЯТ░ Budget Preference: Cost-effective solutions under тВ╣500 preferred
ЁЯМ┐ Method Preference: Organic and sustainable methods first
ЁЯУЕ Current Season: Post-monsoon season (September-October)
ЁЯПк Materials: Focus on locally available items (neem, turmeric, cow dung, compost)

Provide comprehensive, encouraging, and detailed agricultural advice following the exact JSON format. Make your response engaging with emojis, clear formatting, and practical steps that build farmer confidence.`;

      
      // Create a timeout promise for AI requests (25 seconds for detailed responses)
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('AI request timeout')), 25000);
      });
      
      // Handle image if provided
      let aiPromise: Promise<any>;
      if (imageBase64) {
        // Remove data URL prefix if present
        const base64Data = imageBase64.replace(/^data:image\/[a-z]+;base64,/, '');
        aiPromise = model.generateContent([
          { text: prompt + `

ЁЯУ╕ **IMAGE ANALYSIS REQUIRED:**
The farmer has uploaded an image of their crop/farm. Please provide detailed visual analysis:

**ЁЯФН Visual Assessment:**
тАв Identify the crop type and growth stage
тАв Note leaf color, texture, and any discoloration patterns
тАв Look for pest damage, disease symptoms, or nutrient deficiencies
тАв Assess soil condition visible in image
тАв Check plant spacing, overall health, and environmental conditions

**ЁЯТб Image-Specific Insights:**
тАв Describe exactly what you observe in the image
тАв Correlate visual symptoms with possible causes
тАв Provide image-based evidence for your recommendations
тАв Include stage-specific advice based on plant growth visible

**ЁЯОп Targeted Solutions:**
Combine your visual analysis with the farmer's question to provide laser-focused, image-specific advice in your detailed JSON response. Be specific about what you see and how it relates to the solution.` },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: base64Data
            }
          } as any
        ]);
      } else {
        aiPromise = model.generateContent([{ text: prompt }]);
      }

      // Race between AI request and timeout
      let aiResult;
      try {
        aiResult = await Promise.race([aiPromise, timeoutPromise]) as any;
      } catch (error: any) {
        // If we get a 404 model not found error, try fallback models
        if (error.status === 404 && error.message?.includes('not found')) {
          console.log('Model not found, trying fallback model...');
          const fallbackModel = genAI.getGenerativeModel({ 
            model: "gemini-2.0-flash",
            generationConfig: {
              temperature: 0.8,
              maxOutputTokens: 2500,
            },
          });
          
          if (imageBase64) {
            const base64Data = imageBase64.replace(/^data:image\/[a-z]+;base64,/, '');
            aiResult = await fallbackModel.generateContent([
              { text: prompt + `\n\nIMAGE ANALYSIS REQUIRED: Please analyze the uploaded image and provide specific advice based on what you observe.` },
              {
                inlineData: {
                  mimeType: "image/jpeg",
                  data: base64Data
                }
              } as any
            ]);
          } else {
            aiResult = await fallbackModel.generateContent([{ text: prompt }]);
          }
        } else {
          throw error; // Re-throw if it's not a model availability issue
        }
      }
      
      let aiResponse = aiResult.response.text();
      
      console.log('Raw AI Response:', aiResponse); // Debug log
      
      // Clean the response thoroughly to get pure JSON
      console.log('Raw AI Response:', aiResponse);
      
      // Remove markdown formatting and extra text
      let cleanedResponse = aiResponse
        .replace(/```json\s*/g, '')
        .replace(/```\s*/g, '')
        .replace(/^[^{]*({.*})[^}]*$/s, '$1')  // Extract JSON from surrounding text
        .trim();
      
      // Try to parse AI response as JSON
      try {
        const parsedResponse = JSON.parse(cleanedResponse);
        
        console.log('Parsed AI Response:', parsedResponse);
        
        // Validate that we have the required fields from AI
        if (parsedResponse.title && parsedResponse.text && parsedResponse.steps && Array.isArray(parsedResponse.steps)) {
          response = {
            title: parsedResponse.title,
            text: parsedResponse.text,
            steps: parsedResponse.steps,
            lang,
            source: "ai",
          };
          console.log('тЬЕ Using complete AI response');
        } else {
          console.log('тЪая╕П AI response missing some fields, using hybrid approach');
          // Missing required fields, use template with AI text if available
          response = {
            title: parsedResponse.title || titles[lang] || titles.en,
            text: parsedResponse.text || `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
            steps: Array.isArray(parsedResponse.steps) ? parsedResponse.steps : stepsMap[lang] || stepsMap.en,
            lang,
            source: "ai",
          };
        }
      } catch (parseError) {
        console.log('JSON Parse Error:', parseError); // Debug log
        console.log('Attempting JSON extraction from response...'); // Debug log
        
        // Try to extract JSON from the response if it's embedded in text
        let extractedJson = null;
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
          try {
            extractedJson = JSON.parse(jsonMatch[0]);
            console.log('Successfully extracted JSON:', extractedJson); // Debug log
            
            if (extractedJson.title && extractedJson.text && extractedJson.steps) {
              response = {
                title: extractedJson.title,
                text: extractedJson.text,
                steps: extractedJson.steps,
                lang,
                source: "ai",
              };
            } else {
              throw new Error('Extracted JSON missing required fields');
            }
          } catch (extractError) {
            console.log('JSON extraction failed:', extractError); // Debug log
            extractedJson = null; // Make sure it's null for the next check
          }
        }
        
        // If JSON extraction failed, clean and format the AI text
        if (!extractedJson) {
          let cleanText = aiResponse;
          
          // Try to extract meaningful content if it looks like JSON
          if (aiResponse.includes('{') && aiResponse.includes('}')) {
            try {
              // Attempt to extract text from malformed JSON
              const textMatch = aiResponse.match(/"text"\s*:\s*"([^"]+)"/);
              if (textMatch) {
                cleanText = textMatch[1];
              } else {
                // Fallback: clean up JSON-like formatting
                cleanText = aiResponse
                  .replace(/[{}"[\]]/g, '')
                  .replace(/title\s*:\s*/gi, '')
                  .replace(/text\s*:\s*/gi, '')
                  .replace(/steps\s*:\s*/gi, '')
                  .replace(/lang\s*:\s*/gi, '')
                  .replace(/source\s*:\s*/gi, '')
                  .replace(/,\s*$/gm, '')
                  .trim();
              }
            } catch {
              // If all else fails, use the original response but clean it up
              cleanText = aiResponse.replace(/[{}"[\]]/g, '').trim();
            }
          }
          
          response = {
            title: titles[lang] || titles.en,
            text: cleanText || `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
            steps: stepsMap[lang] || stepsMap.en,
            lang,
            source: "ai",
          };
        }
      }
    } catch (error) {
      console.error('AI generation failed:', error);
      console.log('Falling back to template response');
      // Fallback to template response
      response = {
        title: titles[lang] || titles.en,
        text: `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
        steps: stepsMap[lang] || stepsMap.en,
        lang,
        source: "template",
      };
    }
  } else {
    // No AI API key configured, use template response
    response = {
      title: titles[lang] || titles.en,
      text: `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
      steps: stepsMap[lang] || stepsMap.en,
      lang,
      source: "template",
    };
  }
  
  console.log('Final response:', response); // Debug log
  return res.json(response);
};