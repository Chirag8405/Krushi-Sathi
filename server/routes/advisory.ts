import { RequestHandler } from "express";
import { z } from "zod";
import { GoogleGenerativeAI } from "@google/generative-ai";
import type { AdvisoryRequest, AdvisoryResponse, LangCode } from "@shared/api";

const ReqSchema = z.object({
  question: z.string().optional(),
  imageBase64: z.string().optional(),
  lang: z.custom<LangCode>(),
});

const titles: Record<string, string> = {
  en: "Crop Advisory",
  ml: "р┤Хр╡Гр┤╖р┤┐ р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤В",
  hi: "рдХреГрд╖рд┐ рд╕рд▓рд╛рд╣",
  mr: "рдкрд┐рдХ рд╕рд▓реНрд▓рд╛",
  kn: "р▓мр│Жр▓│р│Ж р▓╕р▓▓р▓╣р│Ж",
  gu: "рккрк╛ркХ рк╕рк▓рк╛рк╣",
  te: "р░кр░Вр░Я р░╕р░▓р░╣р░╛",
};

const stepsMap: Record<string, string[]> = {
  en: ["Inspect leaves", "Isolate affected area", "Apply organic pesticide", "Control irrigation"],
  ml: ["р┤Зр┤▓р┤Хр╡╛ р┤кр┤░р┤┐р┤╢р╡Лр┤зр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤мр┤╛р┤зр┤┐р┤д р┤нр┤╛р┤Чр┤В р┤╡р╡Зр╡╝р┤др┤┐р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤Ьр╡Ир┤╡ р┤Хр╡Ар┤Яр┤ир┤╛р┤╢р┤┐р┤ир┤┐ р┤кр╡Нр┤░р┤пр╡Лр┤Чр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х", "р┤╡р╡Жр┤│р╡Нр┤│р┤В р┤ир┤┐р┤пр┤ир╡Нр┤др╡Нр┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х"],
  hi: ["рдкрддреНрддреЛрдВ рдХреА рдЬрд╛рдБрдЪ рдХрд░реЗрдВ", "рд╕рдВрдХреНрд░рдорд┐рдд рднрд╛рдЧ рдЕрд▓рдЧ рдХрд░реЗрдВ", "рдЬреИрд╡рд┐рдХ рдХреАрдЯрдирд╛рд╢рдХ рд▓рдЧрд╛рдПрдБ", "рд╕рд┐рдВрдЪрд╛рдИ рдирд┐рдпрдВрддреНрд░рд┐рдд рдХрд░реЗрдВ"],
  mr: ["рдкрд╛рдиреЗ рддрдкрд╛рд╕рд╛", "рд╕рдВрдХреНрд░рдорд┐рдд рднрд╛рдЧ рд╡реЗрдЧрд│рд╛ рдХрд░рд╛", "рд╕реЗрдВрджреНрд░рд┐рдп рдХреАрдЯрдХрдирд╛рд╢рдХ рд╡рд╛рдкрд░рд╛", "рдкрд╛рдгреА рдирд┐рдпрдВрддреНрд░рд┐рдд рдХрд░рд╛"],
  kn: ["р▓Ор▓▓р│Жр▓Чр▓│р▓ир│Нр▓ир│Б р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓┐р▓╕р▓┐", "р▓кр│Ар▓бр▓┐р▓д р▓нр▓╛р▓Чр▓╡р▓ир│Нр▓ир│Б р▓мр│Зр▓░р│Нр▓кр▓бр▓┐р▓╕р▓┐", "р▓╕р│Зр▓Вр▓жр│Нр▓░р│Ар▓п р▓Хр│Ар▓Яр▓ир▓╛р▓╢р▓Х р▓мр▓│р▓╕р▓┐", "р▓ир│Ар▓░р▓╛р▓╡р▓░р▓┐ р▓ир▓┐р▓пр▓Вр▓др│Нр▓░р▓┐р▓╕р▓┐"],
  gu: ["рккрк╛ркВркжркбрк╛ ркдрккрк╛рк╕рлЛ", "рк╕ркВркХрлНрк░ркорк┐ркд ркнрк╛ркЧ ркЕрк▓ркЧ ркХрк░рлЛ", "рк╕ркЬрлАрк╡ ркХрлАркЯркирк╛рк╢ркХ рк▓ркЧрк╛рк╡рлЛ", "рк╕рк┐ркВркЪрк╛ркИ ркирк┐ркпркВркдрлНрк░рк┐ркд ркХрк░рлЛ"],
  te: ["р░Жр░Хр▒Бр░▓р░ир▒Б р░кр░░р░┐р░╢р▒Ар░▓р░┐р░Вр░Ър░Вр░бр░┐", "р░мр░╛р░зр░┐р░д р░нр░╛р░Чр░╛р░ир▒Нр░ир░┐ р░╡р▒Зр░░р▒Бр░Ър▒Зр░пр░Вр░бя┐╜я┐╜я┐╜", "р░╕р▒Зр░Вр░жр▒Нр░░р▒Ар░п р░кр▒Бр░░р▒Бр░Чр▒Бр░ор░Вр░жр▒Б р░╡р░╛р░бр░Вр░бр░┐", "р░кр░╛р░░р▒Бр░жр░▓ р░ир░┐р░пр░Вр░др▒Нр░░р░┐р░Вр░Ър░Вр░бр░┐"],
};

const intro: Record<string, string> = {
  en: "Here are personalized steps for your crop.",
  ml: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤╡р┤┐р┤│р┤пр╡Нр┤Хр╡Нр┤Хр╡Н р┤Жр┤╡р┤╢р╡Нр┤пр┤ор┤╛р┤п р┤╕р┤╣р┤╛р┤п р┤ир┤┐р╡╝р┤жр╡Нр┤жр╡Зр┤╢р┤Щр╡Нр┤Щр╡╛ р┤др┤╛р┤┤р╡Ж р┤ир╡╜р┤Хр┤┐р┤пр┤┐р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б.",
  hi: "рдЖрдкрдХреА рдлрд╕рд▓ рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рд╕рд▓рд╛рд╣ рдиреАрдЪреЗ рджреА рдЧрдИ рд╣реИред",
  mr: "рддреБрдордЪреНрдпрд╛ рдкрд┐рдХрд╛рд╕рд╛рдареА рдЖрд╡рд╢реНрдпрдХ рдкрд╛рдпрд▒реНрдпрд╛ рдЦрд╛рд▓реА рджрд┐рд▓реЗрд▓реНрдпрд╛ рдЖрд╣реЗрдд.",
  kn: "р▓ир▓┐р▓ор│Нр▓о р▓мр│Жр▓│р│Жр▓Чр▓╛р▓Чр▓┐ р▓╡р│Ир▓пр▓Хр│Нр▓др▓┐р▓Х р▓╣р▓Вр▓др▓Чр▓│р│Б р▓Хр│Жр▓│р▓Чр│Ж р▓ир│Ар▓бр▓▓р▓╛р▓Чр▓┐р▓жр│Ж.",
  gu: "ркдркорк╛рк░рлА рккрк╛ркХ ркорк╛ркЯрлЗ рк╡рлНркпркХрлНркдрк┐ркЧркд рккркЧрк▓рк╛ркВ ркирлАркЪрлЗ ркЖрккрлЗрк▓ ркЫрлЗ.",
  te: "р░ор▒А р░кр░Вр░Я р░Хр▒Лр░╕р░В р░╕р▒Вр░Ър░ир░▓р▒Б р░Хр▒Нр░░р░┐р░Вр░ж р░Йр░ир▒Нр░ир░╛р░пр░┐.",
};

export const postAdvisory: RequestHandler = async (req, res) => {
  const parsed = ReqSchema.safeParse(req.body as AdvisoryRequest);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });
  const { question = "", lang, imageBase64 } = parsed.data;

  // Basic image size validation (~4/3 of bytes to base64 length). Limit ~5MB.
  if (imageBase64) {
    const approxBytes = Math.ceil((imageBase64.length * 3) / 4);
    if (approxBytes > 5 * 1024 * 1024) {
      return res.status(413).json({ error: "Image too large (max 5MB)" });
    }
  }

  const safeQuestion = String(question).slice(0, 2000);
  const useAI = !!process.env.AI_API_KEY;

  let response: AdvisoryResponse;
  if (useAI) {
    try {
      // Initialize Google Gemini AI with configuration
      const genAI = new GoogleGenerativeAI(process.env.AI_API_KEY!);
      const model = genAI.getGenerativeModel({ 
        model: "gemini-1.5-flash",
        generationConfig: {
          temperature: 0.8, // Slightly higher for more engaging responses
          maxOutputTokens: 2500, // Increased for structured, engaging content
        },
      });

      // Create comprehensive system prompt for engaging agricultural advice
const systemPrompt = `You are Dr. Krishi, a friendly and experienced agricultural expert with 25+ years of field experience across Indian farming systems. Provide engaging, easy-to-understand advice for farmers in ${lang === 'en' ? 'English' : 'the local language'}.

IMPORTANT: You must respond ONLY with a valid JSON object. Do not include any explanatory text before or after the JSON. Do not wrap the JSON in markdown code blocks. Your entire response must be this exact format:
{
  "title": "Brief, actionable title (max 60 characters)",
  "text": "Engaging, step-wise explanation written in conversational style with clear sections and bullet points",
  "steps": ["Step 1: Clear action with timing", "Step 2: Specific treatment method", "Step 3: Monitoring technique", "Step 4: Prevention strategy"],
  "lang": "${lang}",
  "source": "ai"
}

WRITING STYLE for the "text" field:
- Use conversational, friendly tone like talking to a friend
- Break content into clear sections with headings like "ЁЯФН What's happening:", "ЁЯТб Why this occurs:", "ЁЯЫая╕П Solution approach:"
- Use bullet points and numbered lists within the text
- Include emojis sparingly for visual appeal
- Keep sentences short and clear
- Use local farming terminology farmers understand
- Add encouraging phrases like "Don't worry, this is fixable!" or "Many farmers face this"

CONTENT STRUCTURE for the "text" field:
ЁЯФН **Problem Identification:**
- Acknowledge the farmer's concern warmly
- Clearly identify what's happening

ЁЯТб **Root Cause:**
- Explain why this happens in simple terms
- Mention common triggers (weather, season, etc.)

ЁЯЫая╕П **Treatment Options:**
1. **Organic solution** (preferred, cost-effective)
2. **Alternative method** (if organic doesn't work)
3. **Chemical backup** (last resort)

тП░ **Best Timing:**
- When to apply treatments
- Time of day considerations

ЁЯФН **How to Monitor:**
- Signs of improvement to watch for
- Warning signs of worsening

ЁЯЫбя╕П **Prevention Tips:**
- How to avoid this in future
- Seasonal preparation advice

Guidelines for your response:
тЬУ Write like you're talking to a neighbor farmer over tea
тЬУ Use simple, practical language that any farmer can understand
тЬУ Focus on solutions that work with limited resources
тЬУ Include cost estimates when possible (тВ╣50-100 range preferred)
тЬУ Mention locally available materials (neem, turmeric, cow dung, etc.)
тЬУ Give specific timings (early morning, after sunset, etc.)
тЬУ Add encouraging words and confidence boosters
тЬУ Keep everything practical and actionable
тЬУ Use bullet points and clear sections within the text
тЬУ Include both quick fixes and long-term solutions

STEPS field guidelines:
- Each step should be ONE specific action
- Include timing/frequency in each step
- Start with the most urgent action
- End with prevention for next season
- Use action verbs: "Mix", "Apply", "Check", "Spray"
- Be specific about quantities and timing

Make your advice:
тЬУ Practical and implementable for small-scale farmers
тЬУ Focused on sustainable and organic methods first
тЬУ Include both immediate and long-term solutions
тЬУ Culturally appropriate for Indian farming practices
тЬУ Cost-effective using locally available materials when possible
тЬУ Safe for farmers, crops, and environment

Remember: Farmers rely on this advice for their livelihood. Be thorough, accurate, and compassionate.`;

      let prompt = systemPrompt + `

FARMER'S QUESTION: "${safeQuestion}"

CONTEXT:
- Location: Indian agricultural context
- Farmer Type: Small to medium scale farming
- Language Preference: ${lang === 'en' ? 'English' : 'Local Indian language'}
- Season: Consider current season in India (September - post-monsoon/kharif season)

Please provide your detailed agricultural advisory in the JSON format specified above.`;

      
      // Create a timeout promise for AI requests (15 seconds for better reliability)
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('AI request timeout')), 15000);
      });
      
      // Handle image if provided
      let aiPromise: Promise<any>;
      if (imageBase64) {
        // Remove data URL prefix if present
        const base64Data = imageBase64.replace(/^data:image\/[a-z]+;base64,/, '');
        aiPromise = model.generateContent([
          { text: prompt + `

IMAGE ANALYSIS REQUIRED:
The farmer has uploaded an image of their crop/farm. Please:
1. Carefully analyze the image for signs of disease, pests, nutrient deficiency, or other issues
2. Identify the crop type if possible
3. Note any visible symptoms (leaf discoloration, spots, wilting, insect damage, etc.)
4. Assess the overall plant health and growing conditions
5. Provide specific advice based on what you observe in the image
6. Include image-specific recommendations in your detailed response

Combine your image analysis with the farmer's question to provide the most accurate and helpful advice.` },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: base64Data
            }
          } as any
        ]);
      } else {
        aiPromise = model.generateContent([{ text: prompt }]);
      }

      // Race between AI request and timeout
      const aiResult = await Promise.race([aiPromise, timeoutPromise]) as any;
      let aiResponse = aiResult.response.text();
      
      console.log('Raw AI Response:', aiResponse); // Debug log
      
      // Clean the response if it has markdown formatting
      aiResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      
      // Try to parse AI response as JSON, fallback to template if parsing fails
      try {
        const parsedResponse = JSON.parse(aiResponse);
        
        // Validate that we have the required fields from AI
        if (parsedResponse.title && parsedResponse.text && parsedResponse.steps && Array.isArray(parsedResponse.steps)) {
          response = {
            title: parsedResponse.title,
            text: parsedResponse.text,
            steps: parsedResponse.steps,
            lang,
            source: "ai",
          };
        } else {
          // Missing required fields, use template with AI text if available
          response = {
            title: parsedResponse.title || titles[lang] || titles.en,
            text: parsedResponse.text || `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
            steps: parsedResponse.steps || stepsMap[lang] || stepsMap.en,
            lang,
            source: "ai",
          };
        }
      } catch (parseError) {
        console.log('JSON Parse Error:', parseError); // Debug log
        console.log('Attempting JSON extraction from response...'); // Debug log
        
        // Try to extract JSON from the response if it's embedded in text
        let extractedJson = null;
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        
        if (jsonMatch) {
          try {
            extractedJson = JSON.parse(jsonMatch[0]);
            console.log('Successfully extracted JSON:', extractedJson); // Debug log
            
            if (extractedJson.title && extractedJson.text && extractedJson.steps) {
              response = {
                title: extractedJson.title,
                text: extractedJson.text,
                steps: extractedJson.steps,
                lang,
                source: "ai",
              };
            } else {
              throw new Error('Extracted JSON missing required fields');
            }
          } catch (extractError) {
            console.log('JSON extraction failed:', extractError); // Debug log
            extractedJson = null; // Make sure it's null for the next check
          }
        }
        
        // If JSON extraction failed, clean and format the AI text
        if (!extractedJson) {
          let cleanText = aiResponse;
          
          // Try to extract meaningful content if it looks like JSON
          if (aiResponse.includes('{') && aiResponse.includes('}')) {
            try {
              // Attempt to extract text from malformed JSON
              const textMatch = aiResponse.match(/"text"\s*:\s*"([^"]+)"/);
              if (textMatch) {
                cleanText = textMatch[1];
              } else {
                // Fallback: clean up JSON-like formatting
                cleanText = aiResponse
                  .replace(/[{}"[\]]/g, '')
                  .replace(/title\s*:\s*/gi, '')
                  .replace(/text\s*:\s*/gi, '')
                  .replace(/steps\s*:\s*/gi, '')
                  .replace(/lang\s*:\s*/gi, '')
                  .replace(/source\s*:\s*/gi, '')
                  .replace(/,\s*$/gm, '')
                  .trim();
              }
            } catch {
              // If all else fails, use the original response but clean it up
              cleanText = aiResponse.replace(/[{}"[\]]/g, '').trim();
            }
          }
          
          response = {
            title: titles[lang] || titles.en,
            text: cleanText || `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
            steps: stepsMap[lang] || stepsMap.en,
            lang,
            source: "ai",
          };
        }
      }
    } catch (error) {
      console.error('AI generation failed:', error);
      console.log('Falling back to template response');
      // Fallback to template response
      response = {
        title: titles[lang] || titles.en,
        text: `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
        steps: stepsMap[lang] || stepsMap.en,
        lang,
        source: "template",
      };
    }
  } else {
    // No AI API key configured, use template response
    response = {
      title: titles[lang] || titles.en,
      text: `${safeQuestion ? `Question: ${safeQuestion}. ` : ""}${intro[lang] || intro.en}`,
      steps: stepsMap[lang] || stepsMap.en,
      lang,
      source: "template",
    };
  }
  
  console.log('Final response:', response); // Debug log
  return res.json(response);
};